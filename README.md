# Домашнє завдання 9

## Завдання

Вам необхідно написати дві функції для касової системи, яка видає решту покупцеві:

1. Функція жадібного алгоритму `find_coins_greedy`. Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми 113 це буде словник {50: 2, 10: 1, 2: 1, 1: 1}. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.
2. Функція динамічного програмування `find_min_coins`. Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми 113 це буде словник {1: 1, 2: 1, 10: 1, 50: 2}

## Виконання

Домашнє завдання виконано у файлах find_coins_greedy.py та find_min_coins.py.

Наступні параметри будуть використані за замовчуванням, якщо не було передано з командного рядку жодного:

-   сума решти: `113`
-   набір монет: `[50, 25, 10, 5, 2, 1]`

## Функція `find_coins_greedy`

Домашнє завдання виконано у файлах find_coins_greedy.py.

### Приклад запуску функції

```
python find_coins_greedy.py [сума решти] [набір монет]
```

```
python find_coins_greedy.py
python find_coins_greedy.py 113
python find_coins_greedy.py 113 50,25,10,5,2,1
```

### Приклад роботи функції

Запуск програми

```
python find_coins_greedy.py
```

Результат виконання

```
Функція "find_coins_greedy"
---------------------------
Маємо набір монет [50, 25, 10, 5, 2, 1]
Сума решти 113
Набір монет для решти: 50x2, 10x1, 2x1, 1x1
```

## Функція `find_min_coins`

Домашнє завдання виконано у файлі find_min_coins.py.

### Приклад запуску функції

```
python find_min_coins.py [сума решти] [набір монет]
```

```
python find_min_coins.py
python find_min_coins.py 113
python find_min_coins.py 113 50,25,10,5,2,1
```

### Приклад роботи функції

Запуск програми

```
python find_min_coins.py
```

Результат виконання

```
Функція "find_min_coins"
------------------------
Маємо набір монет [50, 25, 10, 5, 2, 1]
Сума решти 113
Набір монет для решти: 1x1, 2x1, 10x1, 50x2
```

## Експеримент

В ході експеременту було зроблено декілька замірів для різних сум решти. Дані були занесені у таблицю. для порівняння.

| Сума решти | find_coins_greedy                              | find_min_coins                                 |
| ---------- | ---------------------------------------------- | ---------------------------------------------- |
| 13         | 0.000005489 секунд, 10x1, 2x1, 1x1             | 0.000024868 секунд, 1x1, 2x1, 10x1             |
| 113        | 0.000006182 секунд, 50x2, 10x1, 2x1, 1x1       | 0.000075366 секунд, 1x1, 2x1, 10x1, 50x2       |
| 15327      | 0.000005830 секунд, 50x306, 25x1, 2x1          | 0.011192281 секунд, 2x1, 25x1, 50x306          |
| 5632197    | 0.000006395 секунд, 50x112643, 25x1, 10x2, 2x1 | 3.819801047 секунд, 2x1, 10x2, 25x1, 50x112643 |

### Висновок

Слід зазначити, що обидва алгоритми на малому числі використовуються достатньо швидко. Але при порівнянні на виликих числах -
жадібний алгоритм `find_coins_greedy` показає себе більш ефективним. Суть жадібних алгоритмів полягає в тому, що вони на кожному кроці вибирають найкращий локальний варіант, сподіваючись, що це приведе до оптимального глобального рішення. Цей підхід вирізняється своєю швидкістю і простотою, але варто зазначити, що він не завжди гарантує досягнення глобального оптимуму, що робить його не ідеальним для всіх сценаріїв використання. Про це треба памʼятати.

Затрумку динамічного алгоритму `find_min_coins` можна пояснити тим, що у його випадку ми будуємо таблицю і додаємо до неї значення, коли як у випадку жадібного алгоритму, ми ділемо на монету і далі працюємо з залишком.

Динамічне програмування, яке використовує паʼмять лінійно, програє жадімним алгоритмам, які працюють з константною памʼятю.
